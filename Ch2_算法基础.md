## 笔记

### 2.1 插入排序

###### 代码实现

```java
public int[] insertionSort(int[] nums) {
	for (int j = 1; j < nums.length; j++) {
		int key = nums[j];
    // Insert nums[j] into the sorted sequence nums[1..j-1]
    int i = j - 1;
    while (i >= 0 && nums[i] > key) {
	    nums[i + 1] = nums[i];
      i = i - 1;
    }
    nums[i + 1] = key;
	}
	return nums;
}
```

###### 正确性证明

> 循环不变式主要用来证明算法的正确性。 循环不变式必须证明以下三条性质：
>
> - 初始化：循环的第一次迭代之前为真；
> - 保持：如果循环的某次迭代之前为真，那么下次迭代之前仍为真；
> - 终止：在循环终止时，不变式为我们提供一个有助于证明算法是正确的性质；

假设待排序数组为 $A[0..n-1]$ 

$A[0..j-1]$ 子数组构成当前排序好的数，$A[j]$ 为当前数，$A[j+1..n-1]$ 为未排序的数。

- 初始化：$A[0..j-1]$ 仅单个元素 $A[0]$ 组成，且该子数组是排序好的。所以第一次循环之前(当 $j=1$ 时)，循环不变式成立。
- 保持：$for$ 循环内将 $A[j-1]$、$A[j-2]$ 等依次向右移动一个位置，直到找到 $A[j]$ 的适当位置。这时子数组 $A[0..j]$ 由原来的 $A[0..j]$ 中的元素组成，且已按序排列。$for$ 循环的下一次迭代增加j将保持循环不变式。
- 终止：for循环终止条件是j>n-1，因此最终j=n，在循环不变式中将j用n代替，则子数组A[0..n-1]由原来在A[0..n-1]中的元素组成，且已按序排好。

## 练习题

###### 2.1-1 以图2-2为模型，说明 INSERTION-SORT 在数组 A=[31，41，59，26，41，58] 上的执行过程。。

1. A=[31, ==41==,59, 26, 41, 58] 
2. A=[31, 41, ==59==, 26, 41, 58] 
3. A=[==26==, ***31, 41, 59***, 41, 58] 
4. A=[26, 31, 41, ==41==, 59, 58]
5. A=[26, 31, 41, 41, ==58==, 59]
6. A=[26, 31, 41, 41, 58, 59]

###### 2.1-2 重写过程 INSERTION-SORT，使之按非升序(而不是非降序)排序

```java
public int[] insertionSort(int[] nums) {
	for (int j = 1; j < nums.length; j++) {
		int key = nums[j];
    // Insert nums[j] into the sorted sequence nums[1..j-1]
    int i = j - 1;
    while (i >= 0 && nums[i] < key) {
	    nums[i + 1] = nums[i];
      i = i - 1;
    }
    nums[i + 1] = key;
	}
	return nums;
}
```

###### 2.1-3 考虑以下查找问题：

> 输入：$n$ 个数的一个序列 $A=[a_1, a_2, ..., a_n]$ 和一个值 $v$。
>
> 输出：下标 $i$ 使得 $v=A[i]$ 或者当 $v$ 不在 $A$ 中出现时， $v$ 为特殊值 NIL。
>
> 写出线性查找的伪代码，它扫描整个序列来查找 $v$。使用一个循环不变式来证明你的算法是正确的。确保你的循环不变式满足三条必要的性质。

```java
public int[] insertionSort(int[] nums, int v) {
	for (int j = 0; j < nums.length; j++) {
		int key = nums[j];
    if ( key == v ){
			return j;
		}
	}
	return null;
}
```

###### 2.1-4 考虑把两个 n 位二进制整数加起来的问题，这两个整数分别存储在两个 n 元数组 A 和 B 中。这两个整数的和应按二进制形式存储在一个(n+1)元数组C中。请给出该问题的形式化描述，并写出伪代码。





### 2.2 分析算法





## 思考题



